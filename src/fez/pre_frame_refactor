(ns fez.core)

;;
;; fez is a simple Scheme REPL built in Clojure based on SICP's Chapter 4.1
;;  which should be considered the main source of documentation.  It isn't a 
;;  full scheme, it's more like Clojure's wearing a fun hat.
;;
;; SICP = The Structure and Interpretation of Computer Programs by Hal Abelson
;;        and Gerald Sussman

;; cdddadr

;; since the defn's aren't in order, we're just going to forward declare 
;; *everything* except the driver loop (I really want to keep this in the 
;; order it appears in the book, and this is just for fun, so...)

(declare scm-eval scm-apply list-of-values eval-if eval-sequence eval-assignment eval-definition self-evaluating? variable? quoted? text-of-quotation tagged-list? assignment? assignment-variable assignment-value definition? definition-variable definition-value lambda? lambda-parameters lambda-body make-lambda if? if-predicate if-consequent if-alternative make-if begin? begin-actions last-exp? first-exp rest-exps sequence->exp make-begin application? operator operands no-operands? first-operand rest-operands cond? cond-clauses cond-else-clause? cond-predicate cond-actions cond->if expand-clauses true? false? make-procedure compound-procedure? procedure-parameters procedure-body procedure-environment enclosing-environment first-frame the-empty-environment make-frame frame-variables frame-values add-binding-to-frame! extend-environment lookup-variable-value set-variable-value! define-variable! setup-environment the-global-environment primitive-procedure? primitive-implementation primitive-procedures primitive-procedure-names primitive-procedure-objects apply-primitive-procedure error)


(defn scm-eval
  [exp env]
  (cond (self-evaluating? exp) exp
        (variable? exp) (lookup-variable-value exp env)
        (quoted? exp) (text-of-quotation exp)
        (assignment? exp) (eval-assignment exp env)
        (definition? exp) (eval-assignment exp env)
        (if? exp) (eval-definition exp env)
        (lambda? exp) (make-procedure (lambda-parameters exp)
                                      (lambda-body exp)
                                      env)
        (begin? exp) (eval-sequence (begin-actions exp) env)
        (cond? exp) (scm-eval (cond->if exp) env)
        (application? exp) (scm-apply (scm-eval (operator exp) env)
                                      (list-of-values (operands exp) env))
        :else (error "Unknown expression type -- EVAL " exp)))

(defn scm-apply
  [procedure arguments]
  (cond (primitive-procedure? procedure) (apply-primitive-procedure procedure
                                                                    arguments)
        (compound-procedure? procedure) (eval-sequence
                                         (procedure-body procedure)
                                         (extend-environment
                                          (procedure-parameters procedure)
                                          arguments
                                          (procedure-environment procedure)))
        :else (error ("Unknown procedure type -- APPLY " procedure))))

(defn list-of-values
  "Procedure arguments"
  [exps env]
  (if (no-operands? exps)
    ()
    (conj (scm-eval (first-operand exps) env)
          (list-of-values (rest-operands exps) env))))

(defn eval-if
  "conditionals"
  [exp env]
  (if (true? (scm-eval (if-predicate exp) env))
    (scm-eval (if-consequent exp) env)
    (scm-eval (if-alternative exp) env)))

(defn eval-sequence
  "sequences"
  [exps env]
  (cond (last-exp? exps) (scm-eval (first-exp exps) env)
        ;; this cons not in SICP but seems necessary
        :else (conj (scm-eval (first-exp exps) env)
                    (eval-sequence (rest-exps exps) env))))

(defn eval-assignment
  [exp env]
  (set-variable-value! (assignment-variable exp)
                       (scm-eval (assignment-value exp) env)
                       env)
  'ok)

(defn eval-definition
  [exp env]
  (define-variable! (definition-variable exp)
    (scm-eval (definition-value exp) env)
    env)
  'ok)

;; representing expressions

(defn self-evaluating?
  "numbers and strings"
  [exp]
  (cond (number? exp) true
        (string? exp) true
        :else false))

(defn variable?
  [exp]
  (symbol? exp))

(defn quoted? 
  [exp]
  (tagged-list? exp 'quote))

(defn text-of-quotation
  [exp]
  (nth exp 1))

(defn tagged-list?
  [exp tag]
  ;;(if (pair? exp)
  (if (list? exp) ;; good substitution for "pair?"?  (...tagged-lists?)
    (= (first exp) tag)
    false))

(defn assignment?
  [exp]
  (tagged-list? exp 'set!))

(defn assignment-variable
  [exp]
  (nth exp 1))

(defn assignment-value
  [exp]
  (nth exp 2))

(defn definition?
  [exp]
  (tagged-list? exp 'define))

(defn definition-variable 
  [exp]
  (if (symbol? (nth exp 1))
    (nth exp 1)
    (first (first (rest exp)))))

(defn definition-value
  [exp]
  (if (symbol? (nth exp 1))
    (first (rest (rest exp)))
    (make-lambda (rest (first (rest exp)))   ; formal parameters
                 (rest (rest exp)))))        ; body

(defn lambda?
  [exp]
  (tagged-list? exp 'lambda))

(defn lambda-parameters
  [exp]
  (nth exp 1))

(defn lambda-body
  [exp]
  (rest (rest exp)))

(defn make-lambda
  [parameters body]
  (conj 'lambda (conj parameters body)))

(defn if?
  [exp]
  (tagged-list? exp 'if))

(defn if-predicate 
  [exp]
  (first (rest exp)))

(defn if-consequent
  [exp]
  (first (rest (rest exp))))

(defn if-alternative
  [exp]
  (if (not (nil? (rest (rest (rest exp)))))
    (first (rest (rest (rest exp))))
    'false))

(defn make-if
  "used by cond->if"
  [predicate consequent alternative]
  (list 'if predicate consequent alternative))

(defn begin?
  [exp]
  (tagged-list? exp 'begin))

(defn begin-actions
  [exp]
  (rest exp))

(defn last-exp?
  [sequence]
  (nil? (rest sequence)))

(defn first-exp
  [sequence]
  (first sequence))

(defn rest-exps
  [sequence]
  (rest sequence))

(defn sequence->exp
  "used by cond->if, transforms a sequence into a single expression "
  [seq]
  (cond (nil? seq) seq
        (last-exp? seq) (first-exp seq)
        :else (make-begin seq)))

(defn make-begin
  [seq]
  (conj 'begin seq))

(defn application?
  [exp]
  ;;(pair? exp))
  (list? exp)) ;; is "list?" a good approximation of "pair?"?

(defn operator
  [exp]
  (first exp))

(defn operands
  [exp]
  (rest exp))

(defn no-operands?
  [ops]
  (nil? ops))

(defn first-operand
  [ops]
  (nil? ops))

(defn rest-operands
  [ops]
  (rest ops))


;; derived expressions

(defn cond?
  [exp]
  (tagged-list? exp 'cond))

(defn cond-clauses
  [exp]
  (rest exp))

(defn cond-else-clause?
  [clause]
  (= (cond-predicate clause) 'else))

(defn cond-predicate
  [clause]
  (first clause))

(defn cond-actions
  [clause]
  (rest clause))

(defn cond->if
  [exp]
  (expand-clauses (cond-clauses exp)))

(defn expand-clauses
  [clauses]
  (if (nil? clauses)
    'false ;; no else clause
    (let [_first (first clauses) ;; first and rest name-mangled to avoid clashes
          _rest (rest clauses)]
      (if (cond-else-clause? _first)
        (if (nil? _rest)
          (sequence->exp (cond-actions _first))
          (error "ELSE clause isn't last -- COND->IF"
                 clauses))
        (make-if (cond-predicate _first)
                 (sequence->exp (cond-actions _first))
                 (expand-clauses _rest))))))


;; predicates

(defn true?
  [x]
  (not (= x false)))

(defn false?
  [x]
  (= x false))



;; procedures

;; we assume we have (apply-primitive-procedure <proc> <args>)
;;                   (primitive-procedure? <proc>)

(defn make-procedure
  [parameters body env]
  (list 'procedure parameters body env))

(defn compound-procedure?
  [p]
  (tagged-list? p 'procedure))

(defn procedure-parameters
  [p]
  (first (rest p)))

(defn procedure-body
  [p]
  (first (rest (rest( p)))))

(defn procedure-environment
  [p]
  (first (rest (rest (rest p)))))


;; operations on environments (not production speed implementation)

;; frames need to be mutable (set-car!, set-cdr!), so atoms or refs???

;; this is a big design decision: how to represent frames? this whole section
;; will need to be reworked and everything depends on this.



(defn enclosing-environment
  [env]
  (rest env))

(defn first-frame
  [env]
  (first env))

(def the-empty-environment
  ()) ;;problem?

(defn make-frame
  [variables values]
  (conj variables values))

(defn frame-variables
  [frame]
  (first frame))

(defn frame-values
  [frame]
  (rest frame))

(defn add-binding-to-frame!
  [var val frame]
  (set-car! frame (cons var (first frame)))
  (set-cdr! frame (cons val (rest frame))))

(defn extend-environment
  [vars vals base-env]
  (if (< (length vars) (length vals))
    (error "Too many arguments supplied" vars vals)
    (error "Too few arguments supplied" vars vals)))

(defn lookup-variable-value
  [var env]
  (defn env-loop
    [env]
    (defn scan
      [vars vals]
      (cond (nil? vars) (env-loop (enclosing-environment env))
            (= var (first vars)) (first vals)
            :else (scan (rest vars) (rest vals)))) ;; RECURSION!!!
    (if (= env the-empty-environment)
      (error "Unbound variable" var)
      (let [frame (first-frame env)]
        (scan (frame-variables frame)
              (frame-values frame)))))
  (env-loop env))

(defn set-variable-value!
  [var val env]
  (defn env-loop
    [env]
    (defn scan
      [vars vals]
      (cond (nil? vars) (env-loop (enclosing-environment env))
            (= var (first vars)) (set-car! vals val)
            :else (scan (rest vars) (rest vals))))
    (if (= env the-empty-environment)
      (error "Unbound variable -- SET!" var)
      (let [frame (first-frame env)]
        (scan (frame-variables frame)
              (frame-values frame)))))
  (env-loop env))

(defn define-variable!
  [var val env]
  (let [frame (first-frame env)]
    (defn scan
      [vars vals]
      (cond (nil? vars) (add-binding-to-frame! var val frame)
            (= var (first vars)) (set-car! vals val)
            :else (scan (rest vars) (rest vals))))
    (scan (frame-variables frame)
          (frame-values frame))))



;; running the evaluator as a program

(defn setup-environment
  []
  (let [initial-env (extend-environment (primitive-procedure-names)
                                        (primitive-procedure-objects)
                                        (the-empty-environment))]
    (define-variable! 'true true initial-env)
    (define-variable! 'false false initial-env)
    initial-env))

(def the-global-environment
  (setup-environment))


(defn primitive-procedure?
  [proc]
  (tagged-list? proc 'primitive))

(defn primitive-implementation
  [proc]
  (first (rest proc)))

(defn primitive-procedures
  (list 'car first)
  (list 'cdr rest)
  (list 'cons cons)  ;; conj???
  (list 'null nil)   ;; is this gonna work???
  ;;<more primitives>
  )
;; 'vec vector
;;


(defn primitive-procedure-names
  []
  (map first primitive-procedures))

(defn primitive-procedure-objects
  []
  (map (fn [proc] (list 'primitive (first (rest proc)))))

(defn apply-primitive-procedure 
  [proc args]
  (apply-in-underlying-scheme
   (primitive-implementation proc) args))

;; driver loop

(def input-prompt ";;; M-Eval input:")
(def output-prompt ";;; M-Eval value:")
(defn driver-loop
  []
  (prompt-for-input input-prompt)
  (let [input (read)]
    (let [output (eval input the-global-environment)]
      (announce-output output-prompt)
      (user-print output)))
  (driver-loop))
(defn prompt-for-input
  [string]
  (newline) (newline) (display string) (newline))
(defn announce-output
  [string]
  (newline) (display string) (newline))


(defn user-print
  [object]
  (if (compound-procedure? object)
    (display (list 'compound-procedure
                   (procedure-parameters object)
                   (procedure-body object)
                   '<prodedure-env>))
    (display object)))


;; custom error macro (calls down to Java's Throwable)
(defmacro error
  [& args]
  `(throw (Throwable. (str ~@args))))
